// Pair is a type which is generated by cons procedure.
// Pair has two pointers, which are named car and cdr.
//
// List is expressed by linked list of Pair.
// And procedure application has list which consists of Pair
// as its arguments.

package scheme

import (
	"log"
)

type Pair struct {
	ObjectBase
	Car         Object
	Cdr         *Pair
	environment *Environment
}

func (p *Pair) String() string {
	if p.IsEmpty() {
		return "()"
	} else {
		return "Not implemented."
	}
}

// ***DEPRICATED***
func (p *Pair) EvaledCar() Object {
	switch p.Car.(type) {
	case *Application:
		return p.Car.(*Application).applyProcedure()
	default:
		return p.Car
	}
}

func (p *Pair) IsList() bool {
	return true
}

func (p *Pair) ElementAt(index int) Object {
	if !p.IsList() {
		log.Fatal("ElementAt() was called for not list object")
	} else if index < 0 {
		log.Fatal("ElementAt() was called with negative index")
	}

	pair := p
	for {
		if index == 0 {
			switch pair.Car.(type) {
			case *Application:
				return pair.Car.(*Application).applyProcedure()
			default:
				return pair.Car
			}
		} else {
			pair = pair.Cdr
			index--
		}
	}
}

func (p *Pair) IsEmpty() bool {
	return p.Car == nil && p.Cdr == nil
}

func (p *Pair) ListLength() int {
	if p.IsEmpty() {
		return 0
	} else {
		return p.Cdr.ListLength() + 1
	}
}
